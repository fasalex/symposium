\documentclass[journal]{IEEEtran}
\pagenumbering{arabic}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{psfrag}
\ifCLASSOPTIONcompsoc
   \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\else
   \usepackage[caption=false,font=footnotesize]{subfig}
\fi

\begin{document}
%
% paper title
\title{Decentralized Frame Synchronization of a TDMA-based Wireless Sensor Network}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{}
\IEEEauthorblockA{Fasika Assegei\\ Radiocommunication Group\\
Department of Electrical Engineering\\
Eindhoven University of Technology\\
Eindhoven, The Netherlands\\
Email: f.a.assegei@student.tue.nl}}

\markboth{M.Sc. Graduation Paper F.A.Assegei - Department of Electrical Engineering, TU/e}
{Decentralized Frame Synchronization of a Wireless Sensor Network}

\maketitle

\begin{abstract}
Time synchronization is a crucial component of infrastructure for
\textit{Wireless Sensor Networks}(WSNs). Most applications of WSNs
make extensive use of time synchronization mechanisms like
\emph{Time Division Multiple Access} (TDMA) scheduling, accurate
timestamping of events, coordinate activities of the network or data
fusion. The unique requirements of wireless sensor networks,
compared to traditional networks, in terms of precision, lifetime,
energy and scope of the synchronization achieved, make the
traditional synchronization methods unsuitable for WSNs. This
motivates the research of synchronization methods which are
aligned to the specific properties of WSN. In this research,
different algorithms have been developed to achieve a stable,
convergent and energy-efficient synchronization of a decentralized
WSN. The algorithms achieve synchronization by using the phase error
of a node's wake-up time with that of the neighboring node's and predict
the next wake up time of the node. So, the method avoids time keeping on the messages (time
stamping) which reduces the message overload. The research is concluded with the comparison of
algorithms in terms of energy consumption and performance. A low
energy-consumption or a better precision as well as the length of
the guard time can be used for selecting the algorithm.
\end{abstract}
\begin{IEEEkeywords}
adhoc networks, frame synchronization, decentralized synchronization, wireless sensor networks,
slot synchronization.
\end{IEEEkeywords}

\section{\textbf{Introduction}}

\subsection{\textbf{Wireless Sensor Networks}}
\noindent Technological advances have led to the development of
low-cost sensors, which are capable of wireless communication and
data processing. \textit{Wireless Sensor Networks}(WSNs) are
distributed networks of such sensors, dedicated to closely observing
real-world phenomena. Various applications are realized using WSNs$\cite{10}$.
\newline One of the design issues in WSN technology is clock
synchronization, which is a critical piece of infrastructure in any
distributed system. In WSNs, a number of factors makes
flexible and robust time synchronization particularly important and
more difficult to achieve than in traditional networks.

\subsection{\textbf{Existing Work on WSN clock synchronization}}
\noindent Several algorithms have been proposed
and researched for time synchronization in WSNs. The
\textit{Reference Broadcast Synchronization}(RBS) stated in
$\cite{2}$ is an important scheme in the area of WSN
synchronization. It achieves a Receiver-Receiver pairwise
synchronization to remove sender nondeterminism and results in a
good precision of a few microseconds. A decentralized slot synchronization algorithm based for
TDMA networks which uses the topology of the nodes as a means to
weigh the phase error of the sender with the receiver is presented in $\cite{3}$.
\newline
Another method for achieving a network-wide synchronization is
suggested by $\cite{texas}$. This approach establishes a table to
correspond the clock of the sender with that of the receiver clock so
that a good estimation of the neighbors clock is achieved using different estimation
techniques. $\cite{6}$ presents a different approach to weight based synchronization for
interference elimination for a TDMA based ad-hoc networks. The algorithm
achieves synchronization in a decentralized manner using the nodes offset with its
neighbors with a goal of eliminating the interference.

\subsection{\textbf{Objective and overview of the research}}
The primary objective of this research is to develop an algorithm to
achieve a long time synchronization of a WSN in a low cost and
energy-efficient method which is decentralized and employs no
timestamping on the messages. The methods use the phase errors
between the receiver and its neighbors and predict the next wake up time of the node.
The methods avoids time stamping of the messages, reducing the overload on the message. Besides, there
are no additional synchronization messages, reducing the traffic overload.
In this research, different algorithms are presented to
achieve a long term decentralized synchronization of a WSN and
compared in terms of performance and energy consumption.
\newline The remainder of the paper is organized as follows:  Section 2
presents a general overview of synchronization in WSN and the need
for a synchronized time. Section 3 discusses the synchronization
error and formulate the problem. Section 4 presents the
mathematical models of the algorithms for the synchronization of the
network. In Section 5, the simulation results are presented and the
analysis of the results in addition to the comparison of the methods
with respect to energy consumption is discussed. Finally, Section 6
draws the conclusions from the research and suggests future work.
\section{\textbf{Synchronization in Wireless Sensor Networks}}
\subsection{\textbf{Introduction}}
\noindent Chess$\footnote{Chess is specialized in innovative
technical systems and business critical solutions. Chess creates and
develops sophisticated solutions and products for electronic
systems, transactions and electronic payments, Machine to Machine
(M2M) systems, sensor applications and digital multimedia. Chess is
located in Haarlem, the Netherlands.}$ created a MAC protocol for
gossip communication, gMAC, for the wireless sensor network,
MyriaNed$\footnote{MyriaNed is a project to create a large
functional network of 10,000 nodes with wireless communication for
research on protocols, power management, programming models, and
security.}$, with the gossiping technique in mind. Being a wireless
sensor network, the duty cycle of the network is small, around
1$\%$. Looking back at the 1$\%$ active time versus the $99\%$
nonactive time ratio, it is a non-trivial matter to keep the nodes
time synchronized.
\newline A number of approaches have been
introduced for different multiple access techniques, of which
\textit{Carrier Sense Multiple Access}(CSMA) and \textit{Time
Division Multiple Access}(TDMA) are the most common. One problem
with CSMA is the times when the radio is busy with idle listening
time. Nodes need to listen to the radio for periods of time before
they can actually send data.
\subsection{\textbf{Clock Synchronization in traditional networks}}
\noindent In a centralized system, the solution to clock drift is
trivial: the centralized server will dictate the system time because
time is unambiguous. With the centralized concept in mind, different
protocols have been proposed and implemented to achieve
synchronization in traditional networks, \textit{Network Time Protocol}(NTP)
being the most popular$\cite{5}$.
\newline Synchronization in traditional distributed systems takes
a different kind of approach since there is no central authority to
be referred in case of time requests. But central nodes can be
assigned as to play the role of a server as in the case of the
centralized system. But, most of the time, distributed systems, due
to their unique properties, have no central command. Creation of a
synchronization scheme that satisfies such requirements is
challenging. The task becomes particularly daunting in WSNs, in
light of their additional domain requirements, which are mentioned
below. These complications are startling to look for a new arena for
the synchronization of WSNs.
\subsection{\textbf{The need for a synchronized time}}
There are many reasons why a synchronized time is needed in a WSN.
Some of them include data integration, TDMA scheduling, Target
Tracking and Localization. As previously stated, the WSN being
developed at Chess uses a TDMA protocol for channel access, hence
the reason for synchronization.
\newline TDMA is a channel access method for shared medium (usually
radio) networks. It allows several users to share the same frequency
channel by dividing the signal into different time slots. The users
transmit in rapid succession, one after the other, each using his
own time slot. This allows multiple stations to share the same
transmission medium while using only the part of its bandwidth they
require. Figure $\ref{tdmasch}$ shows how the nodes communicate with
TDMA as the media access protocol.
\newline In this approach, nodes use time slots in order to
communicate with each other. It is considered that two nodes have
their TDMA schedule synchronized when the numbers of the current
time slot of any of the TDMA schedules involved are the same for any
given moment in time. The types of the slot may be different, TX or
RX. To successfully initiate a network, the nodes has to be
synchronized and capable to send and receive messages. To establish
a link between neighboring nodes, a particular node needs to know
the schedule of all its neighbors.
\begin{figure}
\begin{center}
\includegraphics[width=2.5in]{tdmaschedule}
\caption{TDMA Channel access} \label{tdmasch}
\end{center}
\end{figure}
The MAC protocol used in the project is the gMAC$\cite{pieter}$. The
g in gMAC comes from Gossiping, which represents the gossip protocol
implemented in the network layer.
\newline
In order to have a seamless communication between the nodes, the
synchronization of the frames is a necessary part of the MAC
protocol. The processing element and other functions on a WSN
operate on a local oscillator. Due to physical factors, the
frequency of the oscillator has a drift. When no provisions are
taken, it causes the nodes to run out of sync. Given that there is a
certain error, the node will adjust its wake-up time at the end of
the last receiver slot with the offset calculated with an algorithm.
\subsection{\textbf{Wireless Sensor Networks: Why different ?}}
     Are traditional synchronization methods applicable in the case of WSNs? Many
assumptions in the traditional schemes do not hold in the case
of WSNs. Some of these factors can be described as follows:
\begin{itemize}
\item \textbf{Energy Limitation}: Due to their small size and nature of applications which they
are designed for, energy consumption is a major concern in a WSN.
\item \textbf{Dynamic Nature of the Network}: In a WSN, network
dynamics results from various factors like mobility of nodes, node
failures, environmental obstructions etc., which prevents simple
static configurations.
\item \textbf{Diverse Applications}: A variety of applications 
have totally different needs as far as synchronization is concerned.
Some applications might need a global timescale while
some others can work with a local timescale and some require a relative timescale.
\item \textbf{Cost of the Nodes}: Sensor nodes are very small in size
and must be cheap cost wise since they are implemented in large
numbers.
\end{itemize}
\section{\textbf{Problem Formulation}}
\subsection{\textbf{Sources of synchronization error}}
The first step in designing any time-synchronization algorithm would
be to understand why and where it is required. The different factors
which give rise to errors in clocks of nodes or in synchronization
algorithm can be divided into two main categories:\newline
\textbf{Oscillator Characteristics}: The sensor node's clocks run on very cheap oscillators.
      The following two characteristics are the main sources of errors between the clocks
      of two different nodes.
         \begin{itemize}
         \item \emph{\textbf{Accuracy}}: This is a measure of difference between oscillators expected (ideal)
           frequency and actual frequency. 
         \item \emph{\textbf{Stability}}: This is oscillator tendency to stay at the same frequency over
           time.
      \end{itemize}
\textbf{Hardware and Environmental factors}: The non-determinism in the message delivery latency
      is a major source of error. This can be categorized in four type of
      delays:
      \begin{itemize}
         \item \emph{\textbf{Send Time}}: The time spent at the Sender to build the message.
         \item \emph{\textbf{Access Time}}: Delay occurred while waiting for access to the transmit channel.
         \item \emph{\textbf{Propagation Time}}: Time required for the message to travel from sender to receiver.
         \item \emph{\textbf{Receive Time}}: Time needed for processing at the receivers network
         interface.
      \end{itemize}
      All the above factors result in following errors between the clocks of two nodes:
\begin{itemize}
\item \textbf{Phase error}: The oscillators of any two nodes can be out of phase at
any given time, resulting into different time on both clocks. 
\item \textbf{Frequency error}: Frequency error, in contrast, measures the difference in the clockrates.
\item \textbf{Clock drift}: It is not just that the clocks are running at different rates, but even
the frequency of each clock does not stay constant over a period of
time.
\end{itemize}
\subsection{\textbf{Clock and Frequency standards}}
\noindent The quality of a clock usually amounts to its frequency
stability which is the ability of its frequency standard to emit
events at a constant frequency over time. The absolute value of the
frequency compared to the desired value or, its frequency accuracy
is also important. Calibration can easily compensate for an
inaccurate but stable clock.
\newline As per our motive to a synchronized clock, clocks are very
important in this research: the error bound achieved by a clock
synchronization method is linked to both the error inherent in the
method itself, and the stability of the clocks' frequency.
\newline
Most commonly found in computer clocks are quartz crystal oscillators,
characterized by $\cite{6}$. Quartz crystals are attractive because
they are inexpensive, small, use little power, and perform
surprisingly well despite their low resource requirements. The
frequency generated by a quartz oscillator is affected by a number
of environmental factors. A 32 kHz crystal clock $\cite{18}$
$\cite{19}$  is used in the MyriaNode$\footnote{MyriaNode is the
sensor node which is built for the project MyriaNed.}$.
\subsection{\textbf{Clock Drift}}\noindent
In this section, the model for the clock drift of an oscillator is studied.
%\begin{figure}[b]
%\centering
%\includegraphics[width=0.35\textwidth]{actualvsmeasuredtime}
%\caption{Measured time versus real time}
%\label{fig:clocktimevsrealtime}
%\end{figure}
From the definition of frequency:
\begin{equation}
f = d\phi/dt \label{freq_defn} ,
\end{equation}
and integrating both sides over time,
 \begin{equation}
\phi =\int f(t)dt ,
 \end{equation}
where $f$ is frequency, $\phi$ is phase, and $t$ is time.\newline
Thus, the clock time is described as
\begin{equation}
C(t) = \frac{1}{f_o}\int_{t_o}^{t} {f(\tau)d\tau} + C(t_o) ,
\label{clock}
\end{equation}
where $f(\tau)$ is the frequency of the clock, $f_o$ is the nominal
frequency of the crystal oscillator and $t_o$ is the start time of
the node. The exact clock drift is hard to predict because it
depends on environmental influences (such as temperature, pressure
and power voltage). One can usually assume that the clock drift of a
computer clock doesn't exceed a maximum value $\rho$ . This means
that it can be assumed
\begin{equation}
1-\rho \leq \frac{dC(t)}{dt} \leq 1+\rho ,
\end{equation}
where $\rho$ represents the maximum clock drift.
\newline Note that different clocks have different maximum clock drift values
$\rho$.\newline The frequency of the clock is dependent on different
factors and can be given as
\begin{equation}
f_i(t) = f_o + \Delta f + a(t-t_o) + \Delta
f_e(t-t_o) + f_r(t) \label{frequency}
\end{equation}
where \newline $t_o$ = the start time of the clock, \newline $a$ =
aging factor,  \newline $f_o$ = nominal frequency, \newline $\Delta
f$ = calibration error,\newline $f_r(t)$ = frequency instability
(noise) term, \newline $\Delta f_e$ = frequency error which occurs
due to outside factors like temperature, voltage instability. \newline
From ($\ref{clock}$) and
($\ref{frequency}$), we get
\begin{equation}
C_i(t) - C_i(t_o) = \frac{1}{f_o} \int^{t}_{t_o}f_i(\tau)d\tau ,
\end{equation}
\begin{eqnarray*}
C_i(t) - C_i(t_o) & = & \frac{1}{f_o} \int^{t}_{t_o}{[f_o + \Delta f + a(\tau-t_o)  } \\
 &  & {} + \Delta f_e(\tau-t_o) + f_r(\tau)]d\tau ,
\label{fasika}
\end{eqnarray*}
\begin{eqnarray*}
C_i(t) & = & C_i(t_o) + (t-t_o) +\frac{\Delta f}{f_o}(t-t_o) \\
& & + \frac{a}{2f_o}(t-t_o)^2 + \frac{\Delta f_e}{2f_o}(t-t_o)^2 +
\frac{1}{f_o}\int^{t}_{t_o}{f_r(\tau)d\tau} .
\end{eqnarray*}
The amplitude of the short term variations due to noise (clock
jitter) is small enough that they do not cause the clock to
accelerate or decelerate in a very large amount in the long run. But
the environmental term, primarily due to temperature, and the error
due to calibration can be significant. 
\section{\textbf{Synchronicity protocol}}
\subsection{\textbf{Requirements of the algorithm}}
\subsubsection{\textbf{Precise vs. Course synchronization}}Course synchronization
is implemented when a node is joining in the network. After a newly joining node listened the synchronization information sent by 
the other nodes in the network, it adjusts its time slot reference to the time when it detects the synchronization information. Precise synchronization is implemented when a node has already joined in the network, which repeatedly adjusts the diversion of its time slot reference caused by propagation delay and clock drift. In this research, we focus on precise synchronization.
\subsubsection{\textbf{Lifetime}} Lifetime is the interval that clocks
remain synchronized, or the interval over which a particular
timescale is defined. Sensor networks need synchronization over a
wide range of lifetimes, ranging from less than a second to several
years.
\subsubsection{\textbf{Scope}} The scope is the size of the region in
which a timescale is defined. In this research, exploration of a global
synchronization algorithm is conducted.
\subsubsection{\textbf{Internal vs. External Synchronization}}
In many distributed systems, network time
synchronization simply means adjusting the clock to a correct time
from an outsider. In some other cases, synchronization requires internal or relative synchronization: the 
network must be internally consistent, but its relationship to 
outside time standards is not needed or known.
\subsubsection{\textbf{Energy Budget}} The need for energy efficiency
permeates virtually in all aspects of sensor networks design. The
exact energy constraints are difficult to quantify because there is
a wide range of hardware found across the spectrum of network
implementations, and often within a single network.
\subsubsection{\textbf{Convergence Time}} The importance of convergence time
as a metric is directly tied to the need for energy efficiency. If
energy would not be a concern, the chosen form of synchronization
could simply be left running continuously.
\subsubsection{\textbf{Simplicity}} Extra overhead in the message should be avoided. A
timestamp is not needed in the frame in order to decrease the
message overload. Thus, this in turn has an advantage in the energy-constraint WSN, although
it passes most of the burden to the synchronization algorithm to determine the next
wake-up time of the node.
\subsection{\textbf{Synchronization Frequency}}\noindent
In achieving frame synchronization in a TDMA scheduling, a guard
time is given for a fault tolerance which is used to accommodate the
phase errors, as shown in Figure $\ref{guardtime}$.  As the guard time increases,
the probability that the message is received in the time slot
increases although the energy consumption increases.
\newline Decreasing the timing of the synchronization and do periodic
execution of the synchronization of the algorithm greatly reduces
the energy consumption of the wireless
sensor network. Thus, a synchronization period, $T_{sync}$, is
defined here as the period in which the network can stay
synchronized without the application of the synchronization
algorithm.
\begin{figure}
\centering
\includegraphics[width=2.5in]{guardtime}
\caption{Guard time of the nodes} \label{guardtime}
\end{figure}
\newline A time slot can be defined as being expressed in a
number of clock cycles as
\begin{equation}
t_{slot} = kT ,
\end{equation} where $T$ is the period of the time frame in clock cycles and
$t_{slot}$ is the time duration of a TDMA slot and $k$ is the duty
cycle.
\newline With a synchronization period $T_{sync}$ and the
maximum clock drift of a clock $\rho$ , the maximum time difference
between a sender and a receiver is
\begin{equation}
t_{diff} = 2\frac{T_{sync}}{T}\rho ,
\end{equation}
where the factor of $2$ reflects the worst case scenario where each
node's clock drifts in the opposite direction.\newline Since the
relative time difference between two nodes can be in two direction,
the guard time needs to be twice $t_{diff}$,
\begin{equation}
t_{guard}= 2t_{diff} = 4\frac{T_{sync}}{T}\rho.
\end{equation}
At this end, the minimum duration for a time slot $t_{slot}$ is
\begin{equation}
t_{slot} \geq t_{guard} + T_{tx},
\end{equation}
where $T_{tx}$ is the time required to send a packet from one node to other. \newline Each message
that is send within a time slot is exactly received by a neighbor at
a known clock tick number
\begin{equation}
tick_{rx} = T_{tx}+ \frac{t_{guard}}{2} \label{tick}
\end{equation}
Hence, each time when a node receives a message, it has to be
received exactly at the clock tick given by ($\ref{tick}$). Whenever
this number is not equal with the desired one, a phase error is observed. 
\newline Two nodes have a good communication link when they synchronize
their clocks at least once every $T$ that gives the following
relation,
\begin{equation}
\frac{T_{sync}}{T}\geq 1.
\end{equation}
This has a negative impact on the battery life of the nodes. To obtain the value of
$T_{sync}$ for a particular system with a given duty cycle, we have
to solve the next problems
\begin{equation}
t_{guard} \geq 4\rho \frac{T_{sync}}{T}
\end{equation}
\begin{equation}
t_{slot} \geq t_{guard} + T_{tx}
\end{equation}
\begin{equation}
\frac{T_{sync}}{T} \geq 1.
\end{equation}
In general, there is a trade-off in determining $T_{sync}$: increasing
$T_{sync}$ reduces the energy costs of synchronization, on the other
hand we increase the cost of guard time and decrease the network
performance.
\subsection{\textbf{Mathematical Model}}
As it is described earlier, the wake up time of the nodes should be
synchronized in such away that the nodes are synchronized in the
long term, as the TDMA scheduling requires. As part of the message, the nodes are transmitting
the slot number which it is transmitting. This information is used in the determination of the time
that the message is sent.\newline 
The difference between the wake up times of node $i$ and node $j$2 is
\begin{equation}
\Delta t_{ij}^{(n)} = t_i^{(n)} - t_j^{(n)} ,
\end{equation}
where $t_i$ and $t_j$ are the wake-up times of node $i$ and node $j$
at the $n^{th}$ period. The wake-up time of a node at a random time
after $n$ periods of firings after it is turned on is
\begin{equation}
t_i^{(n)} = \sum_{n} T_i^{(n)} + t_{io},
\end{equation}
where  $T_i^{(n)}$ is the period of the crystal clock at the
$n^{th}$ period which changes with time according to
($\ref{frequency}$) and $t_{io}$ is the initial start-up time of the
node. The frequency of the node varies due to the different factors
mentioned in ($\ref{frequency}$). \newline
The difference in the
wake-up time of the nodes is given by
\begin{eqnarray}
\Delta t_{ij} & = & \sum_{n}T_i^{(n)} + t_{io}- (\sum_{n}T_j^{(n)} +
t_{jo}) \\ &=& (\sum_{n}T_i^{(n)} - \sum_{n}T_j^{(n)}) +
(t_{io}-t_{jo}).
\end{eqnarray}
This phase error can be adjusted using two approaches, which are not exclusive. The first
one is adjusting the clock frequency to come up with a better
wake-up time. The second one is to adjust the next wake-up time
depending on the difference between the current wake-up time of the
node and its neighbors. In this research, the second option is
explored due to:
\begin{itemize}
\item The cost of adjusting the frequency of the clock, and 
\item The complexity of the implementation.
\end{itemize}
Hence, the next wake-up time of the node is
dependent on the current wake-up time of its neighbors in relation
to its previous wake-up time,
\begin{equation}
t_i^{(n+1)} = t_i^{(n)} + T_i^{(n)} - \xi_i^{(n)} ,
\end{equation}
where $T_i$ is the period of the node's clock and $\xi_i$ is given
by
\begin{equation}
\xi_i = f(\Delta t_{ij}).
\end{equation}
The function $f$ is based on an algorithm which takes the wake-up
time differences between the node and its neighbors and determines
the optimal offset to be added to the next wake-up time of the node.
\newline Different algorithms are presented here and discussed with the
simulation results presented in the next section of the report.\newline
\subsubsection{\textbf{Median algorithm and the setback}}
The Median algorithm is currently implemented in the MyriaNode.
The algorithm is described as follows:
\begin{enumerate}
\item Nodes broadcast packets.
\item Each receiver records the time that the packet is received according to the local clock.
\item Each receiver $i$ computes its phase offset to
any other node j in the neighborhood as 
\begin{equation}
\Delta t_{ij}^{(n)} = t_i^{(n)} - t_j^{(n)} ,
\end{equation}
where $t_i$ is the wake-up time of node $i$ and $t_j$ is the wake-up
time of node $j$ at the $n^{th}$ period.
\item Receivers compute the median of the offsets
\begin{equation}
\xi_i^{(n)} = m(\Delta t_{ij}^{(n)}) , \forall j
\end{equation}
\item Receivers adjust their wake-up time by the computed offset value,
\begin{equation}
t_{i}^{(n+1)} = t_i^{(n)} + T_i^{(n)} - k\xi_i^{(n)},
\end{equation}
where $k$ is the gain factor.
\end{enumerate}
\begin{figure}[b]
\centering
\includegraphics[width=2.5in]{node_field}
\caption{A WSN scenario} \label{wsn}
\end{figure}
By multiplying the median with a gain factor,
i.e. $k\xi_i^{(n)}$, the output can be adjusted for better
performance. 
\newline As per the application of Median,
there are setbacks on its implementation. In some test-cases, the
algorithm fails to converge or stays unsynchronized for a certain
period of time. This results in a  communication disruption
in places where synchronization is essential.
\newline A typical scenario is presented where the Median
algorithm takes a longer time to achieve synchronization. In Figure
$\ref{wsn}$, a distribution of nodes is shown. Node 10 joins 
the stable network communication through Node 9. Assume Node
9 belongs to two broadcast domains, Node 3's and Node 10's. Thus,
upon the application of the median algorithm, the node tends to
adjust its wake-up time with the median of the offsets from its
neighbors, Node 3 and Node 10. Adjusting the wake-up time, we get
the offset to be
\begin{equation}
\xi_9 = \frac{\Delta t_{910} + \Delta t_{39}}{2}.
\end{equation}
\begin{figure}[t]
\centering
\includegraphics[width= 2.5in]{offsetpic}
\caption{Using median for phase error correction} \label{fasik}
\end{figure}
\noindent With Node 10 being isolated from the well established
network, it has a major drift from the other nodes. Being in sync
with the other nodes, Node 9 will drift away from the network after
its adjustment with the Node 10. It will take more time to
synchronize with the network again. Figure $\ref{fasik}$ shows the state of the network after the
synchronization using the Median. 
\newline So, in order to address this problem, a range of
algorithms are explored in the next subsections to realize an
energy-efficient, more precise and simple frame
synchronization.
\subsubsection{\textbf{Weighted Measurements - Interference-phobic approach}}
One form of approach to tackle the dynamic behavior of a WSN, due to channel conditions as well as collisions, is a
Weighted Measurement (WM) approach. Using this approach, different
weights are given to the different measurements. A weight is added to
the increase the influence of the close by neighbors and ensure
faster synchronization. In addition to that, a new joining neighbor
can get synchronized with out disturbing the existing neighbors,
adjusting its time to the big swarm of nodes. Its a metaphor of "The
Majority Wins". \newline
The offset is then 
\begin{equation}
\xi_i^{(n)} = \sum{w_{ij}^{(n)}\Delta t_{ij}^{(n)}} ,
\end{equation}
where $\sum{w_{ij}^{(n)}= 1}$.
\newline
The weighted adjustment is used to modify the next wake-up time of
the node,
\begin{eqnarray*}
t_i^{(n+1)} &=& t_i^{(n)} + T_i^{(n)} - \xi_i^{(n)} \\ &=& t_i^{(n)}
+ T_i^{(n)} - \sum_{j=0}^N{w_{ij}^{(n)}\Delta t_{ij}^{(n)}} \\ &=&
t_i^{(n)}+ T_i^{(n)} -
\sum_{j=0}^N{w_{ij}^{(n)}(t_i^{(n)}-t_j^{(n)})} \\ &=& T_i^{(n)} + \sum_{j=0}^N{w_{ij}^{(n)}t_j^{(n)}}.
\end{eqnarray*}
\newline
The main task in this algorithm is how to choose the weight factors so that the
stability of the network (timewise) is achieved in a faster time. In
order to see how the weight factors should affect the next wake-up
time of the node, we will discuss the scenarios.
\newline
The weight is selected by the fact that the a node joining a network
should adjust its time with the network that it is joining. After
each measurement, a phase error is associated with the tabled values
to recognize how far is the sending node concerning the time that it
drifted away from the receiving node. The weights are calculated as:
\begin{equation}
\delta_{ij} = ae^{-b\Delta t_{ij}}.
\end{equation}
\begin{figure}[t]
\centering
\includegraphics[width= 2.5in]{weight}
\caption{Weight factors for the phase error distribution}
\label{weight}
\end{figure}
\noindent 
The parameters are selected using the initial conditions, $\delta_{ij}=0.1$ for $\Delta t_{ij}$ = $t_{guard}$ and $\delta_{ij}=1$ for $\Delta t_{ij}$ = 0.
\newline 
As shown in Figure $\ref{weight}$, the closer the phase error is to zero, the
higher weight it is given. The assignment of high
values to the small phase errors will decrease the time it takes to
synchronize  this node with the network.
\newline
In the assignment of the weight factor, there is another issue to be
considered. If all the phase errors are in the lower region, this
corresponds to the fact that the node is a newly joining node to a
well-established and synchronized network.  In order to incorporate the
effect of the distribution of the phase errors, another quantity,
$\delta$, is introduced in the calculation of the weight factors so
that the node will adjust its wake-up time towards the more
stabilized network. This parameter expresses the distribution of the
weight factors ,
\[w_{ij} = \left\{
\begin{array}{l l}
  1 - \delta_{ij},& \quad \mbox{if $m(\delta_{ij}$) $<$ 0.5}\\
 \delta_{ij}, & \quad \mbox{if $m(\delta_{ij}$) $>$ 0.5}\\ \end{array} \right. \]
where $m$ is the mean function.
Hence, the weight moves towards the large phase errors if the node
is a new-comer which wants to join the "already established"
network.
\newline As shown earlier, WM is a two step process in which the first one describes how the nodes
is offsetted from its neighbor whereas the second one describes how the
node is positioned in the network topology which surrounds it.
\newline
Using the weighted approach, a series of measurements will be used
to estimate the next wake-up time of the node, giving less
value/emphasis to the nodes which are out of reach from the other
nodes. 
\subsubsection{\textbf{Non Linear Least Squares - Interference
elimination}} 
\textbf{Non-Linear Least Squares} \newline 
\begin{figure}[b]
\centering
\includegraphics[width=2.5in]{curvefit}
\caption{Curve fitting using logarithmic function} \label{curvefit}
\end{figure}
\noindent 
Non Linear Least Squares (NLLS) curve fitting  is a mathematical procedure for
finding the best fitting curve to a given set of points by
minimizing the sum of the squares of the offsets ("the residuals")
of the points from the curve. In order to fit the curve, we have
chosen the logarithmic curve in order to meet the demand of
adjusting the time offset and stabilize the network. Logarithmic
curve fitting calculates the best fitting logarithmic curve for a
given set of data. A logarithmic function can be used to represent
the distribution of the offsets in the neighborhood,
\begin{equation}
 f(x_i,\beta)= \beta _1 + \beta_2log(x_i),
\end{equation}
where $\beta_1$ and $\beta_2$ are the parameters to be estimated.\newline
\noindent As the phase errors are of stochastic nature, the curve fit
we selected is a non-linear curve. Normalized offset values tend to
be small and follow a curve in such away that the maximum value of
the offset should not be greater than the threshold value that was
intended to be, the synchronization error. See Figure $\ref{curvefit}$.
\newline 
We have a set of $n$ data points(corresponding to $n$ neighbors) which are ($x_1$, $y_1$),
($x_2$, $y_2$),$\dots$,($x_n$, $y_n$), and a curve (model function)
$y= f(x, \beta)$, that in addition to the variable $x$ also depends on
n parameters,
\begin{equation}
\beta = (\beta_1, \beta_2).
\end{equation}
It is desired to find the vector $\beta$ of
parameters such that the curve fits best the given data in the least
squares sense, that is, the sum of squares
\begin{equation}
    S=\sum_{i=1}^{m}r_i^2 ,
\end{equation}
is minimized, where the residuals $r_i$ are given by
\begin{equation}
    r_i = y_i - f(x_i,\beta)
\end{equation}
for i=1,2,$\dots$, $n$.
\newline
The minimum value of $S$ occurs when the gradient is zero. Hence, there are gradient equations to be solved:
\begin{equation}
    \frac{\partial S}{\partial \beta_j}=2\sum_i r_i\frac{\partial r_i}{\partial \beta_j}=0 \ (j=1,2).
\end{equation}
In a non-linear system, the derivatives $\frac{\partial
r_i}{\partial \beta_j}$ are functions of both the independent
variable and the parameters. These gradient equations do not have a
closed solution. Instead, initial values must be chosen for the
parameters. Then, the parameters are refined iteratively, that is,
the values are obtained by successive approximation,
\begin{equation}
    \beta_j^{k+1}=\beta^k_j+\Delta \beta_j.
\end{equation}
Here, $k$ is an iteration number and the vector of increments,
$\Delta \beta_j$, is known as the shift vector. At each iteration,
the model is linearized by approximation to a first-order Taylor
series expansion about $\beta^k$.
\begin{equation}
    f(x_i,\beta)\approx f(x_i,\beta^k) +\sum_j \frac{\partial f(x_i, \beta^k)}{\partial \beta_j} \left(\beta^k_j -\beta_j \right)
\end{equation}
\begin{equation}
 f(x_i,\beta) =f(x_i, \beta^k)+\sum_j J_{ij} \Delta\beta_j.
\end{equation}
The Jacobian, $J$, is a function of constants, the independent
variable and the parameters, so it changes from one iteration to the
next. Thus, in terms of the linearized model,
\begin{equation}
\frac{\partial r_i}{\partial \beta_j}=-J_{ij}
\end{equation}
and the residuals are given by
\begin{equation}
    r_i=\Delta y_i- \sum_{j=1}^{j=n} J_{ij}\Delta\beta_j,
\end{equation}
where
\begin{equation}
 \Delta y_i=y_i- f(x_i, \beta^k).
\end{equation}
Substituting these expressions into the gradient equations and
equating to $0$, we get a matrix notation of
\begin{equation}
    \left(J^TJ\right)\Delta  \beta=J^T\Delta y
\end{equation}
When the observations are not equally reliable, as in case of WSNs
which are being studied, a weighted sum of squares may be minimized
using the weights( Figure $\ref{weight}$ ),
\begin{equation}
    S=\sum_{i=1}^{i=m}W_{ii}r_i^2.
\end{equation}
The normal equations are then
\begin{equation}
    \left(J^TWJ\right)\Delta  \beta=J^TW\Delta y.
\end{equation}
\textbf{Model Design}\newline
As we are developing a decentralized algorithm, the
next wake-up time of the node depends on the current offset that it
has with the other nodes. The distribution of the offset is the
crucial factor in deciding the type of curve which we want to fit
in. The offsets shows how many time units that the neighbor node is
out of touch with the node in focus. The larger the offset is, the
more out-of-sync the node is.\newline 
Since these nodes might have been long enough without synchronizing,
the time offset that they are going to have is large compared to the
nodes which were in the neighborhood during the last round of
communication. Thus, to join the mass of the network rather than the
mass joining the single node, the algorithm is required to push the
synchronization towards the more established network, rather than
away.\newline 
The set of data are the measured time offsets of the node and the
parameters $\beta_1$ and $\beta_2$ are estimated using a least
squares approximation for the function 
\begin{equation}
 f(x_i,\beta)= \beta _1 + \beta_2log(x_i),
\end{equation}
The initial values of the parameters $\beta_1$ and $\beta_2$ is estimated taking into account
the state of the network to be. \newline
As each measurement arrives from the neighbors, an iteration is made in such a way that
the measurement error from a pre-determined offset value is reduced.
This ensures that the phase offset to be added in the next wake-up
time doesn't diverge in a large amount from the predicted value.
Hence, the difference in measured values and thus the offset is
considered big. In the desire to stay in the originally stabilized
network, the nodes tendency to adapt a new environment is very low,
in this case resisting any change that is going to happen to its
wake-up time.
\subsubsection{\textbf{Discrete time Kalman Filter for synchronization}}
\textbf{Discrete time Kalman Filter} \newline
The Kalman filter estimates a process by using a form of feedback
control: the filter estimates the process state at some time and
then obtains feedback in the form of (noisy) measurements. As such,
the equations for the Kalman filter fall into two groups: time
update equations and measurement update equations. The time update
equations are responsible for projecting forward (in time) the
current state and error covariance estimates to obtain the a priori
estimates for the next time step.
\newline
The Kalman filter addresses the general problem of trying to
estimate the state $x$ of a discrete-time controlled process that is
governed by the linear stochastic difference equation
\begin{equation}
 x_k = Hx_{k-1} + Bu_k + w_{k-1} ,
\end{equation}
with a measurement $z$ that is
\begin{equation}
 z_k = Hx_k + v_k.
\end{equation}
The random variables $w_k$ and $v_k$ represent the process and
measurement noise ( respectively). They are assumed to be
independent( of each other), white, and with normal probability
distributions
\begin{equation}
 p(w) \approx N(0,Q),
\end{equation}
\begin{equation}
 p(v) \approx N(0,R).
\end{equation}
With the initial estimates of $x_{k-1}$ and $P_{k-1}$
\begin{equation}
x_k = Hx_{k-1} + Bu_k
\end{equation}
\begin{equation}
P_k = HP_{k-1}H^T + Q
\end{equation}
The measurement update equations are responsible for the feedbacks
i.e. for incorporating a new measurement into the a priori estimate
to obtain an improved a posteriori estimate.
\begin{equation}
K_k = P_kH^T(HP_kH^T + R)^{-1} \label{kalmangain}
\end{equation}
\begin{equation}
x_k = x_k + K_k(z_k - Hx_x)
\end{equation}
\begin{equation}
P_k = (I-K_kH)P_k
\end{equation}
The time update equations can also be thought of as predictor
equations, while the measurement update equations can be thought of
as corrector equations.
\newline
Hence, a priori and a posteriori estimate errors are defined as
\begin{equation}
e_k^- = x_k – \tilde x_k^- ,
\end{equation}
\begin{equation}
e_k =  x_k – \tilde x_k.
\end{equation}
The a priori estimate error covariance is then
\begin{equation}
P_k^- = E[ e_k^- e_k^{-T} ]
\end{equation}
and the a posteriori estimate error covariance is
\begin{equation}
P_k = E[e_k e_k^T]
\end{equation}
Following these, we can see the equation more deeply.
\begin{equation}
\tilde x_k = \tilde x_k + K(z_k-H\tilde x_k).
\label{updatekalman}
\end{equation}
The difference $z_k - H\tilde x_k$ in ($\ref{updatekalman}$) is called
the residual. The residual reflects the discrepancy between the
predicted measurement $H\tilde x_k$ and the actual measurement
$z_k$. A residual of zero means that the two are in complete
agreement. \newline
The matrix K in ($\ref{kalmangain}$) is
chosen to be the gain or blending factor that minimizes the
posteriori error covariance. Taking the derivative of the trace of
the result with respect to K, setting that result equal to zero, and
then solving for K, we get
\begin{equation}
K_k = P_kH^{T}(HP_kH^{T} + R)^{-1}
\end{equation}
\begin{equation}
K_k = \frac{P_kH^T}{HP_kH^T + R} \label{gain}
\end{equation}
Looking at ($\ref{gain}$), it is seen that as the measurement error
covariance $R$ approaches zero, the gain K weights the residual more
heavily. Specifically,
\begin{equation}
\mathop {\lim }\limits_{R_k \to 0 } {K_k} = H^{-1}.
\end{equation}
On the other hand, as the a priori estimate error covariance $P_k$
approaches zero, the gain K weights the residual less heavily.
Specifically,
\begin{equation}
\mathop {\lim }\limits_{P_k \to 0 } {K_k} = 0.
\end{equation}
\textbf{Filter design} \newline
In the selection of the matrices for the synchronization algorithm,
we will consider different situations of the WSN.
\newline
The transition matrix $H$ plays an important role in achieving
the proper synchronization as it determines the weight that should
be put in the previous value, as to how it influences the next
wake-up time. $H$ indicates how fast/slow is the next wake up time should be compared
to it's previous value and/or neighbors. With the stable network where the nodes remain intact,
the wake-up time of the node is expected to be the same despite the
clock drift.
\begin{equation}
\tilde x_k = \tilde x_k + K(z_k-H\tilde x_k) \label{diff},
\end{equation}
where $x_k$ is the previous value of the node's offset, $z_k$ is the measured phase offset of the nodes with one of its neighbors,
and $K$ is the Kalman gain. \newline
The initial estimates are selected from the previous firing time of the node.
Hence, the initial $x$ and $P$ are estimated from the previous values, one period earlier.
This ensures that the nodes are on the same track as the previous time, since the neighbors
remain the same with some exception of mobility and interference.
Hence, to tackle the dynamic nature of the WSN, the
new node joining the network should be synchronized with the already
established "status quo" of the network. 
In the filter design, the covariance matrices $R$ and $Q$ have a significant
role in the overall implementation of the algorithm. $R$ represents how
we value the measured values to affect the result of the outcome and $Q$
sends a signal as to how we have to evaluate the estimated
value.
\newline The estimated values, which base on a stable background are more prone to be right after a
series of firings. On the contrary, the measured values have large
deviations in such away that more of the weight is going to the
estimated values, tending to stabilize the network.
\newline The update equations are applied in the series of measurement
to end up in an optimal(next time) wake-up time of the node.
\subsection{\textbf{Reducing the guard time}}
As the precision of the algorithms decrease (performance increase),
the guard time can also be reduced to conserve energy. This inturn
reduces the duty cycle.
\begin{figure}[b]
\centering
\includegraphics[width=2.5in]{guardtimesaving}
\caption{Guard time saving} \label{guardtimesaving}
\end{figure}
\newline Let $x$ denote the guard time when the median algorithm is
implemented (Figure $\ref{guardtimesaving}$). Thus, the slot
duration will be
\begin{equation}
T_{slot}=2x + T_x ,
\end{equation}
where $T_x$ is the transmit time of the node. \newline With $N$
slots, the time duration of the active period of the node will be
\begin{equation}
NT_{slot}=N(2x + T_x). \label{slot}
\end{equation}
The duty cycle is then
\begin{equation}
D = \frac{NT_{slot}}{T}, \label{duty}
\end{equation}
where $T$ is the period of a time frame. \newline Substituting
($\ref{slot}$) in ($\ref{duty}$) equation, the duty cycle becomes
\begin{equation}
D= \frac{N(2x+T_{slot})}{T}.
\end{equation}
With the better performance achievement with the other algorithms,
the guard time can be reduced depending on the precision of the
algorithm. Let $\epsilon$ be the guard time reduction in clock
cycles. Hence, the new guard time will be $2x-\epsilon$.\newline The
new duty cycle becomes
\begin{equation}
D_n=\frac{(2(x-\epsilon)+T_x)N}{T}.
\end{equation}
Arranging the equation results in
\begin{equation}
D_n= \frac{(2x+T_x)N}{T} - \frac{(2\epsilon)N}{T}.
\end{equation}
Using the value of $\ref{duty}$, it can be written as
\begin{equation}
D_n= D - \frac{(2\epsilon)N}{T}.
\end{equation}
Hence, with a performance increase in $\epsilon$ clk results in the
duty cycle reduction of
\begin{equation}
D - D_n = \frac{(2\epsilon)N}{T}.
\end{equation}
The decrease in the guard time of the slot is thus dependent on the
algorithm's performance ($\epsilon$) and the number of slots in the
frame. As the number of slots increases with a constant performance increase $\epsilon$, the energy conservation
also increases linearly. The number of slots is determined by the
MAC protocol.
\section{\textbf{Results and Discussion}}
\subsection{\textbf{Simulation setup}}
In this section, the simulation setup is given which is used in the
research to test the performance of the presented frame synchronization
algorithms. The simulated wireless sensor network operates in the
2.4GHz ISM band at a data rate of 2Mbps.
We use a Discrete Event Simulator (DES).
\newline A DES will break down a simulation into discrete chunks. Every event will occur at some
countable time moment and will be given in chronological order. The
advantage of this distinction is two-fold. First, simulations will
not be dependant on some real-time clock. Second, events can be
isolated to perform certain measurements.
\newline One such DES is MiXiM$\footnote{MiXiM (Mixed Simulator) is a simulation
framework for wireless and mobile networks using the OMNeT++ $\cite{omnet}$
simulation engine. It is a collaborative project
 between TU Berlin, TU Delft and Universitaet Paderborn.}$. It provides a component architecture for models.
Components are programmed in C++, then assembled into larger
components and models using a high-level language. Octave$\footnote{Octave is a free program
for performing numerical computations which is mostly compatible
with MATLAB. It is part of the GNU project.}$ is used for
interpretation of the data from the network simulator.
\newline
The communication over the channels is done in
a unidisc way. All nodes in range of the radio actually receive the
data, and those that are outside are excluded.\newline The simulation is conducted 1000
times to counter the effect of randomness introduced in the
simulation.
\subsection{\textbf{Simulation Results}}
\begin{figure*}
\centerline{
\subfloat[Number of Nodes - 16]{\includegraphics[width=2.5in]{16output-s0}
\label{16output0}}
\hfil
\subfloat[Number of Nodes - 50]{\includegraphics[width=2.5in]{50output-s0}
\label{50output0}}}
\caption{Simulation results for Static Nodes }
\label{static}
\end{figure*}
The nodes are deployed uniformly across the field. The neighborhood is limited
to 10 nodes. The start up time of the
nodes is random, Gaussian distributed variable, $t_{io}$. The
synchronization error is the difference between the wake-up time of the nodes in the
neighborhood.
\newline
\begin{center}
    \begin{tabular}{ | l | l |}
    \hline
    Duration time frame & 1s \\ \hline
    Radio range & 10 - 30m \\ \hline
    \end{tabular}
\end{center}
\subsubsection{\textbf{Case I}} In the first set of simulation, the
synchronization error is simulated for the nodes which are static,
hence no effect of mobility. The number of nodes is taken to be $16$
and $50$ in the set of simulations.
\newline Figure $\ref{16output0}$
shows the synchronization error for $16$ nodes operating in a static
environment. KF has the lowest synchronization error, at an avergage
of $4clk$. NLLS and WM perform similarly with Median at average of
$13clk$. \newline Figure $\ref{50output0}$ is the result of a
simulation for $50$ nodes. The synchronization error in general
reduces as the number of nodes increases the number of neighbors,
resulting in more data for the synchronization layer. Comparing the
individual algorithms, KF has over $10clk$ performance improvement
than the Median whereas NLLS and WM have a better performance (
$1clk$) than the Median.
\subsubsection{\textbf{Case II}}
\begin{figure*}
\centerline{
\subfloat[Speed - 6km/hr]{\includegraphics[width=2.5in]{16output-s6}
\label{16output6}} \hfil \subfloat[Speed -
20km/hr]{\includegraphics[width=2.5in]{16output-s20}
\label{16output20}}} \caption{Simulation results for 16 Nodes}
\label{16output}
\end{figure*}
In second set of simulations, the mobility of the nodes is taken
into account. Here, the number of the nodes is taken to be $16$. The
simulations are conducted for different speeds, at $6km/hr$ and
$20km/hr$. Chosen speeds emulate the speed of a walking man and an
average speed of a slowly moving vehicle. \newline Figure
$\ref{16output6}$ shows 16 nodes with a constant speed of $6km/hr$
random mobility. As the results shows, WM and NLLS perform better
the synchronization of the frame, $1 clk$ each. KF outperforms all
the best, with $10 clk$ from the median algorithm. \newline The
simulation is also conducted with a speed of $20km/hr$, having
similar results(Figure $\ref{16output20}$). With the increase in the
speed of the nodes, the precision of the algorithms improves. KF,
with an average of of $10 clk$ performs the best, whereas WM and
NLLS perform well too compared with the median, $1 clk$ and $1 clk$
respectively. The relative comparison of the algorithms performance
improvement with the Median is shown in Figure $\ref{16relerror}$. WM
and NLLS perform, on average, $8-10\%$ better than Median. The best
performer, KF, has on average $60\%$ better performance than the
Median one.
\begin{figure}
\centering \includegraphics[width=2.5in]{16output-error}
\caption{Relative error of the algorithms w.r.t. Median}
\label{16relerror}
\end{figure}
\subsubsection{\textbf{Case III}}
\begin{figure*}
\centerline{ \subfloat[Speed -
6km/hr]{\includegraphics[width=2.5in]{50output-s6}
\label{50output6}} \hfil \subfloat[Speed -
20km/hr]{\includegraphics[width=2.5in]{50output-s20}
\label{50output20}}} \caption{Simulation results for 50 Nodes}
\label{50output}
\end{figure*}
In this set of simulations, the number of the nodes is increased, to
$50$. With slowly moving nodes ($6km/hr$), the results are shown in
Figure $\ref{50output6}$. Large disruptions occur due to nodes
moving slowly in the surrounding (leave the network and join again
after some time), resulting in a larger drift with neighbors before
getting back to the network. \newline With a speed of $20km/hr$, the
simulation result is presented in Figure $\ref{50output20}$. With
this speed, the performance is better due to the faster moving
nodes, joining the networks at a faster rate. This helps in getting
synchronized with the nodes in a faster time, without drifting away
for a longer period of time(which is the case in the first set of
nodes with speed of $6km/hr$). Again, for the set of nodes with a
higher speed , a relative comparison is made to see the performance
of the nodes with the median algorithm.\newline The median
algorithms is shown to perform the worst in this case. There are a
lot of disruptions in the network, making it more unstable whereas
the other algorithms adapt to the changes faster.\newline In
general, Figure $\ref{50relerror}$ shows that KF performs the best
against Median algorithm, $45\%$. WM and NLLS perform well against
Median too, $10\%$ each. But it has been shown that the median is
prone to error in case of high dynamics in the network.
\begin{figure}
\centering \includegraphics[width=2.5in]{50output-error}
\caption{Relative error of the algorithms w.r.t. Median}
\label{50relerror}
\end{figure}
In general, the Kalman filter has a better precision and convergence
speed than the rest whereas WM is also doing in precision whereas
NLLS has a better convergence speed.
\subsection{\textbf{Measurements concerning the energy consumption}}
\begin{figure}[b]
\includegraphics[width=0.5\textwidth]{guardsave}
\caption{The energy consumption of Guard time per RX slot}
\label{energyguard}
\end{figure}
As the results in the previous section shows, KF algorithm performs
well in all conditions, so do WM and NLLS. The downside in
implementing these algorithms, despite the performance gain that all
have against the Median is the energy consumption. As the algorithms
are going to be implemented on the sensor nodes, the energy
consumption is a priority in the study of embedded system algorithm
development. The algorithms are written in C and implemented on the
test nodes to see the effect that they are going to have on the
energy consumption of the nodes.
\begin{center}
    \begin{tabular}{ |p{2cm} | p{2.75cm} |}
    \hline
    Algorithm & Average Execution Time \\ \hline
    M &  65 $\mu$s \\ \hline
    NLLS & 82.5 $\mu$s \\ \hline
    WM &   90 $\mu$s \\ \hline
    KF &  150 $\mu$s  \\ \hline
    \end{tabular}
\label{tab}
\end{center}
The table shows the average execution time of the algorithms in
comparison to implemented on the MyriaNode. This doesn't show the
exact energy consumption of the algorithms but it can give us an
approximation on the relative comparison of the algorithms about the
energy consumption on the MyriaNode. As the table shows, the
consumption of WM is 5$\%$ higher than the median algorithms. This
is also true for NLLS and KF which consume 9$\%$ and 4 $\%$ higher
than the median algorithm respectively. \newline
In order to reduce the energy that is going to be spent on the algorithm with
a better performance, the guard time of the slot can be reduced, due
to a better performance showing by KF, WM and NLLS. The energy
consumption of the guard time is shown in Figure $\ref{energyguard}$.
\newline 
With the performance gain obtained, the guard time of the slot
can be decreased, hereby decreasing the energy consumption of the
node in general. Hence, by decreasing the guard time in proportion with the
performance enhancement, we can save energy for the energy demand of
the algorithm.
\section{\textbf{Conclusion and Recommendation}}\noindent
A decentralized frame synchronization of a TDMA-based WSN is achieved
using Weighted Measurements(WM), Non Linear Curve Fitting(NLLS) and
Kalman Filter(KF) methods. A simulation is conducted with different scenarios, especially
taking the effect of mobility. A comparison of the algorithms with the currently implemented Median algorithm
is conducted and the results are presented.
\newline
In a static environment, the KF performs the best whereas the WM and NLLS have shown a similar performance as the
Median. In terms of convergence time, all have shown a similar performance.
\newline
A $60\%$ improvement in the performance of the synchronization can
achieved on average using the Kalman Filter for dynamic WSN. A lower
improvement, $10\%$ and $8\%$ is obtained using WM and NLLS methods
for the synchronization of TDMA frames. Both WM and NLLS show a better tolerance
against Median in a dynamic network. KF estimation of
the next wake up time is the best with its iterative capability and
adaptive nature.
\newline
Using these algorithms for a TDMA-based WSN synchronization (WM, NLLS and KF), the precision of the network increases. This in turn has a positive impact on the network because the synchronization period, $T_{sync}$ can be increased or the guard time of the node's frame, $t_{guard}$ can be reduced to achieve the same performance as the
Median algorithm. 
\newline
But in the downside, the energy consumption of the algorithms is
greater than the Median algorithm's energy consumption as the algorithms are more complex computationally. Analysis is made and presented about the
energy saving made by decreasing the guard time of the slot. 
Communication is around more costlier than computation, on average. A net gain of battery life can thus be achieved by reducing the guard time.
\newline
Median is shown to be still the best choice in a static environment with the current implementation,with less energy consumption and simplicity into consideration. But, for dynamic networks, the other algorithms perform better, in terms of
performance. KF has the edge due to its adaptive nature.
\newline 
\noindent There are some suggestions on the future work of the synchronization algorithms.
\begin{itemize}
 \item
Using Software Defined Radio (SDR) for the inspection of the nodes' wake-up times, evaluation and enhancements on the algorithms, being
implemented on the MyriaNodes, can be achieved to study the effect on the field.
\item
Different software power minimization techniques can be applied to further reduce the
power consumption of the algorithm implementation, making it more
energy-efficient for implementation.
\item As part of reducing the phase error between the clocks, compensating the frequency error using the available resource on the sensor nodes can be used. This can be achieved using the resources like the temperature sensor in the
microcontroller of the MyriaNode.
\end{itemize}
\section{\textbf{Acknowledgment}}\noindent The author would like to thank Frits van der Wateren from Chess Innovation Team for his continuous support, suggestions and advice during the project. Many thanks to dr.ir. Peter Smulders, prof.dr.ir. Erik Fledderus and prof.dr.ir. Peter Baltus from TU/e for their guidance.
\begin{thebibliography}{\textbf{References}}
\bibitem{2}J.Elson, L.Girod, D.Estrin. Fine-grained network time synchronization using reference broadcasts. Proceedings of the 5th Symposium on Operating Systems Design and Implementation ,2002.
\bibitem{3}Q.Yang, and et al. A Decentralized Slot Synchronization Algorithm for TDMA-Based Ad Hoc Networks.
\bibitem{5}NTP Public Services Project http://support.ntp.org/bin/view/Main/WebHome.
\bibitem{taxonomy}E.Anceaume and I.Puaut. A taxonomy of clock synchronization algorithms. IRISA Research Report No. PI1103, IRISA, 1997.
\bibitem{17}Q.Yang and J.Shi. An interference elimination method for decentralized slot synchronization in TDMA-based wireless ad hoc network.
\bibitem{pieter} P.Anemaet. Determining G-MAC potential with $\{$S,L,SCP$\}$-MAC. Masters thesis. Technische Universteit Delft. Delft. August 2008.
\bibitem{6}R.John. Introduction to Quartz Frequency Standards. Technical Report SLCET-TR-92-1, Army Research Laboratory, Electronics and Power Sources Directorate. October 1992.
%\bibitem{7}J.Elson and D.Estrin. Time Synchronization for Wireless Sensor Networks. In Proceedings of the 15th International Parallel and Distributed Processing Symposium. IEEE Computer Society, April 23-27. 2001.
%\bibitem{9}K.Romer. Time Synchronization in Ad Hoc Networks. In Proceedings of the Second ACM International Symposium on Mobile Ad Hoc Networking and Computing, Long Beach, California. 2001.
\bibitem{10}H.Karl and A.Willig. Protocols and Architectures for Wireless Sensor Networks.p3-6. Wiley. July 2006.
\bibitem{11}C.Cordeiro and D.Agrawal. Ad hoc and Sensor Networks Theory and applications. p.429-441. World Scientific Publishing. 2006.
\bibitem{1}F.Zhao and  L.Guibas. Wireless Sensor Networks: an Information Processing approach. p.107-108. Elsevier. 2004.
\bibitem{texas} S.Raje. Time synchronization of in Network-centric sensor networks. Master research. University of Texas, Arlington. Texas. August 2005.
\bibitem{correlation}A.Ebner, H.Rohling, M.Lott, and R.Halfmann. Decentralized Slot Synchronization in Highly Dynamic Ad Hoc Networks. Proc. WPMC '02, Honolulu, Hawaii, Oct. 2002.
\bibitem{14}S.PalChaudhuri and et al. Adaptive Clock Synchronization in Sensor Networks, Information Processing in Sensor Networks, April 2004.
%\bibitem{16}G.Werner-Allen and et al. Firefly-inspired sensor network synchronicity with realistic radio effects. Proceedings of the 3rd international conference on Embedded networked sensor systems, San Diego, California. November 2005.
\bibitem{18} $http://www.golledge.co.uk/pdf/products/xtl\_sm/cc7v.pdf$
\bibitem{19} $http://pdfserv.maxim-ic.com/en/an/AN58.pdf$.
\bibitem{omnet}$http://www.omnetpp.org$.
\bibitem{kalm}$http://www.cs.unc.edu/~welch/kalman/$.
\end{thebibliography}
\end{document}
\textbf{``Unnecessary synchronization wastes resources; insufficient synchronization leads to poor application performance.'' }
\newline
\textbf{``Stay and believe your instincts rather than going for the change''}.
\newline
\textbf{A man with a watch knows what time it is. A man with two watches is never sure. }\newline